{
    "collab_server" : "",
    "contents" : "#' CEB: a celltypes identify platform for single-cell multi-omic data\n#\n#' @param dataset_list a list with multi-omic data\n#' @param feature.filter a boolean variable defines whether to perform gene filtering. Default is \"TRUE\".\n#' @param feature.filter.fraction the fraction of feature filter. Default is 0.06.\n#' @param datatype defines the type of data, which could be \"count\", \"CPM\", \"RPKM\" and \"FPKM\". Default is \"count\".\n#' @param log.trans a boolean variable defines whether to perform log transform. Default is \"FALSE\".\n#' @param SC3 a boolean variable that defines whether to cluster cells using SC3 method. Default is \"TRUE\".\n#' @param gene_filter a boolean variable defines whether to perform gene filtering in SC3 method. Default is \"FALSE\".\n#' @param svm_num_cells defines the mimimum number of cells above which SVM will be run. Default is 5000.\n#' @param tSNE a boolean variable that defines whether to cluster cells using t-SNE method. Default is \"TRUE\".\n#' @param dimensions sets the number of dimensions wanted to be retained in t-SNE step. Default is 3.\n#' @param perplexity sets the perplexity parameter for t-SNE dimension reduction. Default is 30 when number of cells >= tsne_min_cells.\n#' @param tsne_min_cells defines the number of cells in input dataset below which\n#' \\code{tsne_min_perplexity=10} would be employed for t-SNE step. Default is 200.\n#' @param tsne_min_perplexity sets the perplexity parameter of t-SNE step for small datasets (number of cells \\code{<200}).\n#' @param var_genes defines the number of variable genes used by t-SNE analysis, when \\code{tSNE = TRUE}. Default is \"NULL\".\n#' @param kmeans a boolean variable that defines whether to cluster cells using k-means method. Default is \"TRUE\".\n#' @param iter.max sets the maximum number of iterations in k-means method. Default is 100.\n#' @param spectral_cluster a boolean variable that defines whether to cluster cells using spectral cluster method. Default is \"TRUE\".\n#' @param DBSCAN a boolean variable that defines whether to cluster cells using DBSCAN method. Default is \"FALSE\".\n#' @param eps set the parameter eps of DBSCAN. Default is 270.\n#' @param MinPts set the parameter MinPts of DBSCAN. Default is 5.\n#' @param hierarchical_clustering a boolean variable that defines whether to cluster cells using hierarchical cluster method. Default is \"FALSE\".\n#' @param distance_form set the distance form used in hierarchical cluster method. Default is \"euclidean\".\n#' @param SEED sets the seed of the random number generator. Setting the seed to a fixed value can\n#' produce reproducible clustering results. Default is 1.\n#'\n#' @return a summary of the ensemble clustering result\n#' @examples\n#' data(data_RNA)\n#' data(data_Methy)\n#' dataset_list <- list(data_RNA, data_Methy)\n#'\n#' data(data_reallabel)\n#'\n#' CEB_result <- CEB(dataset_list, feature.filter = T, feature.filter.fraction = 0.06,\n#' datatype = \"count\", log.trans = F,\n#' SC3 = T, gene_filter = F, svm_num_cells = 5000,\n#' tSNE = T, dimensions = 3, perplexity = 30, tsne_min_cells = 200,\n#' tsne_min_perplexity = 10, var_genes = NULL,\n#' kmeans = T, iter.max = 100,\n#' spectral_cluster = T,\n#' DBSCAN = F, eps = 270, MinPts = 5,\n#' hierarchical_clustering = F, distance_form = \"euclidean\",\n#' SEED = 1)\n#'\n#' library(\"mclust\")\n#'\n#' # for data_Clark_multiomic\n#' ARI_individual_clustering <- NULL\n#' i = 0\n#' for(i in 1:2){\n#'   for(j in 1:4){\n#'     ARI_individual_clustering <- c(ARI_individual_clustering,\n#'                                    c(adjustedRandIndex(CEB_result[[1]][[i]][j,], reallabel)))\n#'   }\n#' }\n#' # data_Clark_RNA_filter_log_count + data_Clark_methy_filter_log_count的各4种聚类方法共8个结果ARI值\n#' ARI_individual_clustering\n#' write.csv(t(ARI_individual_clustering),file=\"D:\\\\R_work\\\\CEB\\\\ARI_individual_clustering_multiomic.csv\")\n#'\n#'\n#' @export CEB_result\nCEB <- function(dataset_list, feature.filter = T, feature.filter.fraction = 0.06, datatype = \"count\", log.trans = F,\n                SC3 = T, gene_filter = F, svm_num_cells = 5000,\n                tSNE = T, dimensions = 3, perplexity = 30, tsne_min_cells = 200, tsne_min_perplexity = 10, var_genes = NULL,\n                kmeans = T, iter.max = 100,\n                spectral_cluster = T,\n                DBSCAN = F, eps = 270, MinPts = 5,\n                hierarchical_clustering = F, distance_form = \"euclidean\",\n                SEED = 1){\n\n  # -----------------------data processing---------------------------\n  source('FUNCTION_feature_filter.R')\n\n  dataset_filter_list <- NULL\n  if(feature.filter) {\n    for(i in dataset_list)\n      dataset_filter_list <- c(dataset_filter_list, list(feature_filter(i, fraction = feature.filter.fraction)))\n  } else{\n    dataset_filter_list <- dataset_list\n  }\n\n  inputTags_filter_list <- NULL\n  for(i in dataset_filter_list){\n    inputTags_filter_list = c(inputTags_filter_list, list(as.matrix(i)))\n  }\n\n  # ----------------------run my_individual_clustering----------------------------\n  source('FUNCTION_my_individual_clustering.R')\n\n  cluster_results_Clark_list <- NULL\n  cluster_results_Clark <- NULL\n  cluster_number_Clark <- NULL\n\n  for(i in 1:2){\n    word = paste(\"----------calculating dataset\", i, \"------------\", sep = \"\")\n    message(word)\n    cluster_results_filter_log <- NULL\n    cluster_results_filter_log <- my_individual_clustering(inputTags_filter_list[[i]], datatype = datatype, log.trans = log.trans,\n                                                           SC3 = SC3, gene_filter = gene_filter, svm_num_cells = svm_num_cells,\n                                                           tSNE = tSNE, dimensions = dimensions, perplexity = perplexity, tsne_min_cells = tsne_min_cells, tsne_min_perplexity = tsne_min_perplexity, var_genes = var_genes,\n                                                           kmeans = kmeans, iter.max = iter.max,\n                                                           spectral_cluster = spectral_cluster,\n                                                           DBSCAN = DBSCAN, eps = eps, MinPts = MinPts,\n                                                           hierarchical_clustering = hierarchical_clustering, distance_form = distance_form,\n                                                           SEED = SEED)\n    cluster_results_Clark_list <- c(cluster_results_Clark_list, list(cluster_results_filter_log[[1]]))\n    cluster_results_Clark <-rbind(cluster_results_Clark, cluster_results_filter_log[[1]])\n    cluster_number_Clark <-rbind(cluster_results_Clark, cluster_results_filter_log[[2]])\n\n  }\n\n  # ------------------------run cluster_ensemble--------------------------\n  source('FUNCTION_my ensemble functions.R')\n\n  ensemble_results <- NULL\n  ensemble_results_list <- NULL\n  for(i in cluster_results_Clark_list){\n    ensemble_results_each <- cluster_ensemble(i, program.dir = \".\", CSPA = TRUE, SEED = 1)\n    ensemble_results <- rbind(ensemble_results, ensemble_results_each)\n    ensemble_results_list <- rbind(ensemble_results_list, list(ensemble_results_each))\n  }\n\n  CEB_output <- list(cluster_results_Clark_list, ensemble_results_list)\n  return(CEB_output)\n\n\n\n}\n\n",
    "created" : 1590550253867.000,
    "dirty" : false,
    "encoding" : "CP936",
    "folds" : "",
    "hash" : "263941760",
    "id" : "94230492",
    "lastKnownWriteTime" : 1590546631,
    "last_content_update" : 1590546631,
    "path" : "D:/R_work/CEB/R/CEB.R",
    "project_path" : "R/CEB.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}